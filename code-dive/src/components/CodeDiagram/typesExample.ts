import { ParsedTypes } from "../../codeModel/ParsedTypes";
import { IType } from "../../codeModel/Types/IType";
import { Class } from "../../codeModel/Types/Class";
import { Struct } from "../../codeModel/Types/Struct";
import { Interface } from "../../codeModel/Types/Interface";
import { Enum } from "../../codeModel/Types/Enum";

var parsedTypes: any = { classes:
  [ { namespaceDependecies: [ 'System', 'System.Collections' ],
      namespace: 'DoFactory.GangOfFour.Iterator.Structural',
      name: 'MainApp',
      modifiers: [],
      parentInheritances: [],
      fields: [],
      properties: [],
      constructors: [],
      methods:
       [ { type: 'void',
           name: 'Main',
           modifiers: [ 'static' ],
           parameters: [],
           declaredVariables:
            [ { type: 'ConcreteAggregate', name: 'a' },
              { type: 'Iterator', name: 'i' },
              { type: 'object', name: 'item' } ],
           statements:
            [ { statementText: 'ConcreteAggregate a;',
                usedFieldsAndProperties: [],
                usedConstructors: [],
                usedMethods: [],
                usedTypes: [ 'ConcreteAggregate' ] },
              { statementText: 'a = new ConcreteAggregate();',
                usedFieldsAndProperties: [ 'a' ],
                usedConstructors: [ 'ConcreteAggregate' ],
                usedMethods: [],
                usedTypes: [] },
              { statementText: 'a[0] = "Item A";',
                usedFieldsAndProperties: [ 'a' ],
                usedConstructors: [],
                usedMethods: [],
                usedTypes: [] },
              { statementText: 'a[1] = "Item B";',
                usedFieldsAndProperties: [ 'a' ],
                usedConstructors: [],
                usedMethods: [],
                usedTypes: [] },
              { statementText: 'a[2] = "Item C";',
                usedFieldsAndProperties: [ 'a' ],
                usedConstructors: [],
                usedMethods: [],
                usedTypes: [] },
              { statementText: 'a[3] = "Item D";',
                usedFieldsAndProperties: [ 'a' ],
                usedConstructors: [],
                usedMethods: [],
                usedTypes: [] },
              { statementText: 'Iterator i;',
                usedFieldsAndProperties: [],
                usedConstructors: [],
                usedMethods: [],
                usedTypes: [ 'Iterator' ] },
              { statementText: 'i = a.CreateIterator();',
                usedFieldsAndProperties: [ 'i' ],
                usedConstructors: [],
                usedMethods: [ 'a.CreateIterator' ],
                usedTypes: [] },
              { statementText: 'Console.WriteLine("Iterating over collection:");',
                usedFieldsAndProperties: [],
                usedConstructors: [],
                usedMethods: [ 'Console.WriteLine' ],
                usedTypes: [] },
              { statementText: 'object item;',
                usedFieldsAndProperties: [],
                usedConstructors: [],
                usedMethods: [],
                usedTypes: [ 'object' ] },
              { statementText: 'item = i.First();',
                usedFieldsAndProperties: [ 'item' ],
                usedConstructors: [],
                usedMethods: [ 'i.First' ],
                usedTypes: [] },
              { statementText: 'while(item != null) item = i.Next();',
                usedFieldsAndProperties: [ 'item', 'item' ],
                usedConstructors: [],
                usedMethods: [ 'i.Next' ],
                usedTypes: [] },
              { statementText: 'Console.ReadKey();',
                usedFieldsAndProperties: [],
                usedConstructors: [],
                usedMethods: [ 'Console.ReadKey' ],
                usedTypes: [] } ] } ] },
    { namespaceDependecies: [ 'System', 'System.Collections' ],
      namespace: 'DoFactory.GangOfFour.Iterator.Structural',
      name: 'Aggregate',
      modifiers: [ 'abstract' ],
      parentInheritances: [],
      fields: [],
      properties: [],
      constructors: [],
      methods:
       [ { type: 'Iterator',
           name: 'CreateIterator',
           modifiers: [ 'public', 'abstract' ],
           parameters: [],
           declaredVariables: [],
           statements: [] } ] },
    { namespaceDependecies: [ 'System', 'System.Collections' ],
      namespace: 'DoFactory.GangOfFour.Iterator.Structural',
      name: 'ConcreteAggregate',
      modifiers: [],
      parentInheritances: [ 'Aggregate' ],
      fields: [ { type: 'ArrayList', name: '_items', modifiers: [ 'private' ] } ],
      properties:
       [ { type: 'int',
           name: 'Count',
           modifiers: [ 'public' ],
           accessors:
            [ { name: 'get',
                declaredVariables: [],
                parameters: [],
                body:
                 [ { statementText: 'return _items.Count;',
                     usedFieldsAndProperties: [ '_items.Count' ],
                     usedConstructors: [],
                     usedMethods: [],
                     usedTypes: [] } ] } ] },
         { type: 'object',
           name: 'this',
           modifiers: [],
           accessors:
            [ { name: 'get',
                declaredVariables: [],
                parameters: [ { type: 'int', name: 'index', modifier: '' } ],
                body:
                 [ { statementText: 'return _items[index];',
                     usedFieldsAndProperties: [ 'index', '_items' ],
                     usedConstructors: [],
                     usedMethods: [],
                     usedTypes: [] } ] },
              { name: 'set',
                declaredVariables: [],
                parameters: [],
                body:
                 [ { statementText: '_items.Insert(index, value);',
                     usedFieldsAndProperties: [ 'index', 'value' ],
                     usedConstructors: [],
                     usedMethods: [ '_items.Insert' ],
                     usedTypes: [] } ] } ] } ],
      constructors: [],
      methods:
       [ { type: 'Iterator',
           name: 'CreateIterator',
           modifiers: [ 'public', 'override' ],
           parameters: [],
           declaredVariables: [],
           statements:
            [ { statementText: '_items = new ArrayList();',
                usedFieldsAndProperties: [ '_items' ],
                usedConstructors: [ 'ArrayList' ],
                usedMethods: [],
                usedTypes: [] },
              { statementText: 'return new ConcreteIterator(this);',
                usedFieldsAndProperties: [ 'this' ],
                usedConstructors: [ 'ConcreteIterator' ],
                usedMethods: [],
                usedTypes: [] } ] } ] },
    { namespaceDependecies: [ 'System', 'System.Collections' ],
      namespace: 'DoFactory.GangOfFour.Iterator.Structural',
      name: 'Iterator',
      modifiers: [ 'abstract' ],
      parentInheritances: [],
      fields: [],
      properties: [],
      constructors: [],
      methods:
       [ { type: 'object',
           name: 'First',
           modifiers: [ 'public', 'abstract' ],
           parameters: [],
           declaredVariables: [],
           statements: [] },
         { type: 'object',
           name: 'Next',
           modifiers: [ 'public', 'abstract' ],
           parameters: [],
           declaredVariables: [],
           statements: [] },
         { type: 'bool',
           name: 'IsDone',
           modifiers: [ 'public', 'abstract' ],
           parameters: [],
           declaredVariables: [],
           statements: [] },
         { type: 'object',
           name: 'CurrentItem',
           modifiers: [ 'public', 'abstract' ],
           parameters: [],
           declaredVariables: [],
           statements: [] } ] },
    { namespaceDependecies: [ 'System', 'System.Collections' ],
      namespace: 'DoFactory.GangOfFour.Iterator.Structural',
      name: 'ConcreteIterator',
      modifiers: [],
      parentInheritances: [ 'Iterator' ],
      fields:
       [ { type: 'ConcreteAggregate', name: '_aggregate', modifiers: [ 'private' ] },
         { type: 'int', name: '_current', modifiers: [ 'private' ] } ],
      properties: [],
      constructors:
       [ { name: 'ConcreteIterator',
           modifiers: [ 'public' ],
           parameters: [ { type: 'ConcreteAggregate', name: 'aggregate', modifier: '' } ],
           declaredVariables: [],
           statements:
            [ { statementText: '_current = 0;',
                usedFieldsAndProperties: [ '_current' ],
                usedConstructors: [],
                usedMethods: [],
                usedTypes: [] },
              { statementText: 'this._aggregate = aggregate;',
                usedFieldsAndProperties: [ 'this._aggregate', 'aggregate' ],
                usedConstructors: [],
                usedMethods: [],
                usedTypes: [] } ] } ],
      methods:
       [ { type: 'object',
           name: 'First',
           modifiers: [ 'public', 'override' ],
           parameters: [],
           declaredVariables: [],
           statements:
            [ { statementText: 'return _aggregate[0];',
                usedFieldsAndProperties: [ '_aggregate' ],
                usedConstructors: [],
                usedMethods: [],
                usedTypes: [] } ] },
         { type: 'object',
           name: 'Next',
           modifiers: [ 'public', 'override' ],
           parameters: [],
           declaredVariables: [ { type: 'object', name: 'ret' } ],
           statements:
            [ { statementText: 'object ret;',
                usedFieldsAndProperties: [],
                usedConstructors: [],
                usedMethods: [],
                usedTypes: [ 'object' ] },
              { statementText: 'ret = null;',
                usedFieldsAndProperties: [ 'ret' ],
                usedConstructors: [],
                usedMethods: [],
                usedTypes: [] },
              { statementText: 'if(_current < _aggregate.Count - 1) ret = MoveToNextItem();',
                usedFieldsAndProperties: [ '_current', '_aggregate.Count', 'ret' ],
                usedConstructors: [],
                usedMethods: [ 'MoveToNextItem' ],
                usedTypes: [] },
              { statementText: 'return ret;',
                usedFieldsAndProperties: [ 'ret' ],
                usedConstructors: [],
                usedMethods: [],
                usedTypes: [] } ] },
         { type: 'object',
           name: 'MoveToNextItem',
           modifiers: [ 'private' ],
           parameters: [],
           declaredVariables: [],
           statements:
            [ { statementText: '_current = _current + 1;',
                usedFieldsAndProperties: [ '_current', '_current' ],
                usedConstructors: [],
                usedMethods: [],
                usedTypes: [] },
              { statementText: 'return _aggregate[_current];',
                usedFieldsAndProperties: [ '_current', '_aggregate' ],
                usedConstructors: [],
                usedMethods: [],
                usedTypes: [] } ] },
         { type: 'object',
           name: 'CurrentItem',
           modifiers: [ 'public', 'override' ],
           parameters: [],
           declaredVariables: [],
           statements:
            [ { statementText: 'return _aggregate[_current];',
                usedFieldsAndProperties: [ '_current', '_aggregate' ],
                usedConstructors: [],
                usedMethods: [],
                usedTypes: [] } ] },
         { type: 'bool',
           name: 'IsDone',
           modifiers: [ 'public', 'override' ],
           parameters: [],
           declaredVariables: [],
           statements:
            [ { statementText: 'return _current >= _aggregate.Count;',
                usedFieldsAndProperties: [ '_current', '_aggregate.Count' ],
                usedConstructors: [],
                usedMethods: [],
                usedTypes: [] } ] } ] } ],
 structs: [],
 interfaces: [],
 enums: [] }
export const types: IType[] = (parsedTypes as ParsedTypes).classes.map(type => new Class(type) as IType)
    .concat((parsedTypes as ParsedTypes).structs.map(type => new Struct(type)))
    .concat((parsedTypes as ParsedTypes).interfaces.map(type => new Interface(type)))
    .concat((parsedTypes as ParsedTypes).enums.map(type => new Enum(type)));